[ch7-2 캡슐화, 다형성]

* 캡슐화와 접근 제어자
- 접근 제어자를 사용하는 이유 :
  1. 외부로부터 데이터를 보호하기 위해서 
   2.  외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서 (굳이 외부에 노출시킬 필요 없잖아?)

Ex1)
public class Time {
	public int hour;		  ㅡㅡㅡㅡㅡ>	    Time t = new Time();
	public int minute;			    t.hour = 25;    // 멤버변수에 직접 접근 가능
	public int second;
}
 Ex2)
 public class Time {
	private int hour;	// 접근 제어자를 private으로 하여 
	private int minute;	// 외부에서 직접 접근하지 못하도록 한다. 
	private int second;
	
	public int getHour() { return hour; }	    // 메서드는 public으로 해서, 외부에서 메서드를 통해 iv로 접근하도록 함
	public void setHour(int hour) {		    // (메서드를 통한 간접 접근 허용)
		if (hour < 0 || hour > 23) return;
		this.hour = hour;
	}
}
↓
Time t = new Time();
t.setHour(25); 		// hour값을 25로 설정했지만 상단의 setHour메서드 조건으로 인해 25로 바뀌지 않는다.  -> 데이터 보호 

==> 이런 식으로 직접 접근을 막고, 메서드를 통한 간접 접근을 허용하는 것이 '캡슐화'


Ex3)
class Time {
 	private int hour; 	// 0~23사이의 값을 가져야함.
    	private int minute;
    	private int second;

	public void setHour(int hour) {		    // hour값 설정 메서드 	    
		if(hour < 0 || hour > 23) return;   // 0~23사이의 값이 아니면 return을 만나 메서드를 빠져나가도록 

		this.hour = hour;		    // hour값 읽기 메서드
	}

	public int getHour() { return hour; };
}

public class TimeTest {
	public static void main(String[] args) {
		Time t = new Time();
	//	t.hour = -100;	이렇게 접근 말고 
		t.setHour(21);			
		System.out.println(t.getHour());    // 21 (hour값 21로 바뀜) 
		t.setHour(100);			
		System.out.println(t.getHour());    // 21 (hour값 100으로 안바뀜, 유효범위가 아님)
	}
}

---------------------------------------------------------------
* 다형성  (polymorphism) ***** 중요
- 여러 가지 형태를 가질 수 있는 능력
- 조상 타입 참조 변수로 자손 타입 객체를 다루는 것 **

class Tv {
    boolean power;	// 전원상태 (on/off)			 원래대로라면 
    int channel;	// 채널 					 Tv t = new Tv();
								 SmartTv s = new SmartTv(); 처럼
    void power()      { power =! power; }			
    void channelUp()  { ++channel; }				 각 객체에 맞는 리모컨을 주고 다룸
    void channelDown(){ --channel; }			ㅡㅡㅡㅡ>
}
class SmartTv extends Tv {
    String text;	// 캡션(자막)을 보여주기위한 문자열
    void caption() { /* 생략 */ }
}
↓
Tv t = new SmartTv();	// ok. (타입이 불일치여도 ok인 것을 다형성이라고 한다) 

- 객체와 참조변수의 타입이 일치할 때와 일치하지 않을 때의 차이 ?
    SmartTv s = new SmartTv();		// 참조 변수와 인스턴스의 타입이 일치
    Tv          t  = new SmartTv();		// 조상 타입 참조변수로 자손 타입 인스턴스를 참조 
 ▶ 스마트티비 리모컨으로는 스마스티비 기능 7개를 다 다룰 수 있음. (=7개 멤버를 다 다룰 수 있음)
      그러나 그냥 티비 리모컨(스마트티비의 조상)으로는 스마트티비 기능을 5개만 다룰 수 있음.

- 자손 타입의 참조변수로 조상 타입의 객체를 가리킬 순 없음!
    Tv          t  = new SmartTv();		// ok. 허용
  SmartTv  s = new Tv();		// error. 허용 안 됨 (자손 타입이 갖고 있는 멤버가 조상타입의 멤버보다 많을 수 있기 떄문)

* 다형성 정리
Q. 참조변수의 타입은 인스턴스의 타입과 반드시 일치해야 하나요?
A. 아님! 일치하는 것이 보통이지만 일치 하지 않을 수도 있음. (=다형성)

Q. 참조변수가 조상타입일 때와 자손타입일 때의 차이?
A. 참조변수로 사용할 수 있는 멤버의 갯수가 달라짐.

Q. 자손타입의 참조변수로 조상타입의 객체를 가리킬 수 있나요?
A. 아님! 허용되지 않음.

--------------------------------------------------------------------
* 참조변수의 형변환
- 결론 :::  사용할 수 있는 멤버의 갯수를 조절하는 것 (리모컨 바꿔가면서) 
- 조상 자손 관계의 참조변수는 서로 형변환 가능

FireEngine f = new FireEngine();	// 가정) FireEngine클래스와 Ambulance클래스는 Car클래스를 상속받았다고 가정 

Car c = (Car)f;				// ok. 조상인 Car타입으로 형변환 (생략 가능)
FireEngine f2 = (FireEngine)c;		// ok. 자손인 FireEngine타입으로 형변환 (생략 불가)
Ambulance a = (Ambulance)f;		// error. 상속관계가 아닌 클래스 간의 형변환 불가 (형제관계)

Ex)
class Ex7_7 {
    public static void main(String args[]) {
	Car car = null;
	FireEngine fe = new FireEngine();
	FireEngine fe2 = null;
	
	fe.water();
	car = fe;		// car = (Car)fe; 에서 형변환이 생략됨
//	car.water();		//  error. Car타입의 참조변수로는 water()를 호출할 수 없다.
	fe2 = (FireEngine)Car;	// 자손타입 ← 조상타입. 형변환 생략 불가
	fe.water();
    }
}

class Car {					  |		class FireEngine extends Car {    // 소방차
    String color;				  |			void water() {	   // 물을 뿌리는 기능
    int door;					  |				System.out.println("water! ");
						  |			}
    void drive() {    // 운전하는 기능		  |		  }
	System.out.println("drive ~");				
    }
    void stop() {     // 멈추는 기능
	System.out.println("stop! ");
    }
}
-------------------------------------------------------------------
* instanceof 연산자
- 참조변수의 형변환 가능 여부 확인에 사용. 형변환이 가능하면 true 반환
- 형변환 전에 반드시 instanceof로 확인해야 함 
  ex)
   void doWork(Car c) {
      if (c instanceof FireEngine) {	     // 1. 형변환이 가능한지 확인 (c가 가르키는 객체가 FireEngine의 자손이냐? 란 의미)
   	   FireEngine fe = (FireEngine)c;    // 2. (1.에서 ture가 나오면) 형변환
	   fe.water();
	   ...
  
  FireEngine fe = new FireEngine();
  System.out.println(fe instanceof Object); 		// true
   System.out.println(fe instanceof Car); 		// true
   System.out.println(fe instanceof FireEngine); 		// true

Q. 참조변수의 형변환은 왜 하나요?
A. 참조변수(리모콘)을 변경함으로써 사용할 수 있는 멤버의 갯수를 조절하기 위해

---------------------------------------------------------------------------
---------------------------------------------------------------------------
* 다형성의 장점 ***
1. 다형적 매개변수 
2. 하나의 배열로 여러 종류의 객체 다루기 
↓

1. 다형적 매개변수 (= 매개변수의 다형성)
- 참조형 매개변수는 메서드 호출 시, 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다.
ex)
class Product {
     int price;		// 제품가격
     int bonuspoint;	// 보너스점수
}
class Tv extends Product {}
class Computer extends Product {}
class Audio extends Product {}

class Buyer {     // 물건사는 사람 
     int money = 1000;	// 소유 금액
     int bonusPoint = 0;// 보너스점수
}

// 물건사는 사람에 buy 메서드를 추가해주고 싶다고 가정.

void buy(Tv t) {
	money -= t.price;
	bonusPoint += t.bonusPoint;	// 매개변수를 Tv로 주면, Computer도 Audio도 각각 추가해줘야 해서 불편/유지보수에 불리
}

// ↓ 이렇게 바꾸자.

void buy(Product p) {
	money -= p.price;
	bonusPoint += p.bonusPoint;	// Tv타입의 조상타입인 Product를 매개변수로 쓰자.
}

// 그럼 위 buy 메서드 하나로 여러 물건을 buy할 수 있다.

Buyer b = new Buyer();				
Tv tv = new Tv();
Computer com = new Computer();					
b.buy(tv);
b.buy(com);

Product p1 = new Tv();		// 다형성 (조상 타입의 참조변수로 자손 객체를 가리킴)
Product p2 = new Computer();	// 다형성
Product p3 = new Audio();	// 다형성

==> 장점 1 : 메서드 하나로 여러 개의 물건을 살 수 있다. 

2. 여러 종류의 객체를 배열로 다루기 
- 조상 타입의 배열에 자손들의 객체를 저장할 수 있다.
ex)								
Product p1 = new Tv();						Product p[] = new Product[3];
Product p2 = new Computer();			=		p[0] = new Tv();
Product p3 = new Audio();					p[1] = new Computer();
								p[2] = new Audio();

==> 배열 p에는 다형성으로 여러 종류의 객체(Tv, Computer, Audio)가 있을 수 있게 되는 것임.

class Buyer {	 // 물건사는 사람
	int money = 1000;	// 소유금액
	int bonusPoint = 0;	// 보너스점수

	Product[] cart = new Product[10];	// 구입한 금액을 담을 배열 
	int i = 0;
	void buy(Product p) {
		if(money < p.price) {
			System.out.println("잔액부족");
			return;
		}
		money -= p.price;
		bonusPoint += p.bonusPoint;
		cart[i++] = p;	// 물건을 사면 카트에 담기
	}
}

------------------------------------------------------------------
