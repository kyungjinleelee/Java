[ch7 상속, 포함, 오버라이딩]

* 상속  (Inheritance)
▶ 기존의 클래스로 새로운 클래스를 작성하는 것 (코드의 재사용)
▶ 두 클래스를 부모와 자식으로 관계를 맺어주는 것 

  class 자식클래스 extends 부모클래스{
	// ...
  }

  ex)
  class Parent{}
  class Child extends Parent{	// Child 클래스와 Parent 클래스를 상속 관계에 있다고 한다.
	// ...
  }

▶ 자손은 조상의 모든 멤버를 상속받는다. (생성자, 초기화블럭 제외)
▶ 즉 자손의 멤버 개수는 조상보다 적을 수 없다. (같거나 많다.) 

  ex)
  class Parent{
	int age;
  }
  class Child extends Parent {}	 // Child클래스의 멤버가 0개처럼 보이지만 실은 1개다. (Parent클래스의 멤버가 1개이기 때문에)

▶ 자손의 변경은 조상에 영향을 미치지 않는다.
  ex)
   class Parent{
	int age;
  }
  class Child extends Parent {
	void play() {		 // 새로운 멤버 추가했지만 조상인 Parent클래스에는 영향 주지 않는다. Child클래스 총 멤버는 2개
		System.out.println("놀자~");
	}
  }

------------------------------------------------------------------
* 포함 관계
▶ 포함(composite)이란?
- 클래스의 멤버로 참조변수를 선언하는 것 
ex)
class Circle {
   int x;  // 원점의 x좌표			class Circle {
   int y;  // 원점의 y좌표	ㅡㅡㅡㅡ> 	     Point c = new Point();	// 원점 		 class Point {
   int r;  // 반지름 				     int r;			// 반지름		int x;
}						}  							int y;
==> Circle이 Point를 '포함' 관계에 있음.								 }

- 작은 단위의 클래스를 만들고, 이 둘을 조합해서 클래스를 만든다.
ex) '자동차'라는 클래스를 만들 때 
class Car {
   Engine e = new Engine();	// 엔진
     Door[] d = new Door[4];	// 문, 문의 개수를 넷으로 가정하고 배열로 처리
   // ...
}
==> 멤버들을 다 쓰는 것 보다는, 작은 단위의 클래스를 만들고 이를 조합해서 클래스를 만들기
==> 그럼 복잡도가 줄어들고 재사용성이 늘어난다.

--------------------------------------------------------------------
* 클래스 간의 관계 설정 
- 상속관계 : '~은 ~이다.(is-a)'
- 포함관계 : '~은 ~을 가지고 있다.(has-a)'

Q. 상속관계로 할 지 포함관계로 할 지 긴가민가할 때 
A. 문장을 만들어 보고 어떤 문장이 더 자연스러운지 본다 ! 
  ex) 원(Circle)은 점(Point)이다.		- Circle is a Point.
     원(Circle)은 점(Point)을 가지고 있다. - Circle has a Point. // 이 문장이 더 자연스러움 > 포함 관계로 관계설정 한다.

     class Circle {
	 Point p = new Point();		// 참조변수 선언과 초기화까지 필수로 해줘야 함
	 int r;
     } 	// ==> 사실 대부분의 경우(90%)가 포함 관계이다.
     public class InheritanceTest {
	public static void main(String[] args){
		Circle c = new Circle();
		c.p.x = 1;		// 접근 방법 주의 
		c.p.y = 2;
		c.r = 3;
		System.out.println(c.p.x);	// 1
		System.out.println(c.p.y);	// 2
		System.out.println(c.p.z);	// 3
	}
     }
---------------------------------------------------------------------
* 단일 상속  (Single Inheritance)
- java는 단일상속만을 허용한다.     (C++은 다중상속 허용, 다중상속이 장점도 있지만 단점도 있기에 자바는 포기한 것)
  ex)
   class TvDVD extends Tv, DVD {    // error. 조상은 하나만 허용됨 
	// ... 
  }	

- 비중이 높은 클래스 하나만 상속관계로, 나머지는 포함관계로 한다.
  ex) 
  class TvDVD extends Tv {           // Tv는 상속으로 처리
	DVD dvd = new DVD();	// DVD는 포함으로 처리 ( 1. DVD 객체 만들기)

	void play() {		// 2. DVD가 갖고있는 메서드들을 간단히 호출  
	   dvd.play();
	} 
	void stop() {
	   dvd.stop();
	}
	...
  }


* Object 클래스 : 모든 클래스의 조상
- 부모가 없는 클래스는 자동적으로 Object 클래스를 상속받게 됨	(컴파일러가 자동으로 추가)
- 모든 클래스는 Object 클래스에 정의된 11개의 메서드를 상속받음 	      ex) toString(), equals(Object obj), hashCode(), ...
	public static void main(String[] args){
		Circle c = new Circle();
		System.out.println(c.toString());	// "Circle@15db9742"
		System.out.println(c);			// "Circle@15db9742" 위와 똑같은 코드 나옴 (객체의 주소)
	}

-------------------------------------------------------------
* 오버라이딩  (= 메서드 오버라이딩)
- 상속받은 조상의 메서드를 자신에 맞게 변경하는 것

class MyPoint3 {
	int x;
	int y;
	String getLocation() {
	   return "x:"+ x +", y:"+ y;
	}
}

class MyPoint3D extends MyPoint3{
	int z;

	String getLocation() {	      // 조상의 getLocation()을 오버라이딩
	    return "x:"+ x +", y:"+ y +", x:"+ x;
	}
}
///////////////////////////////////////////
class MyPoint3 {
	int x;
	int y;

	MyPoint3(int x, int y){	      // main에서 '한번에 생성 + 초기화'를 위한 추가문
	   this.x = x;
	   this.y = y;
	}

	public String toString() {    // Object 클래스의 toString()을 오버라이딩
	   return "x:"+ x +", y:"+ y;
	}
}

public class OverrideTest{
	public static void main(String[] args){
		MyPoint3 p = new MyPoint3(3, 5) // 한번에 생성 + 초기화 
		System.out.println(p);		// 아래 5줄 코드가 이 2줄 코드가 됐다 ! 

//		MyPoint3 p = new MyPoint3();  // 객체 생성
//		p.x = 3;
//		p.y = 5;
//		System.out.println(p.x);	
//		System.out.println(p.y); 이 줄 대신 
//		System.out.println(p.toString()); 이거. 이걸 더 간단히 하면
//		System.out.println(p);		// 참조변수 p만 출력해주면 편함
	}
}


* 오버라이딩의 조건 
  1. 선언부가 조상 클래스의 메서드와 일치해야 함  		      (선언부 : 반환타입, 메서드이름, 매개변수 목록)
   2. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없음  (public, protected, private)
   3. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없음
     class Parent {
	 void parentMethod() throws IOException, SQLException {	 // 예외의 갯수 2개
		// ...
	 }
     }
     class Child extends Parent {
	 void parentMethod() throws IOException {		// 예외의 갯수 1개 (조상 메서드보다 같거나 적어야함)
		// ...
	 }
     }

* 오버로딩 vs 오버라이딩 
- 이름만 비슷하지 서로 관계가 아예 없음 ! 

▶ 오버로딩    : 기존에 없는 새로운 메서드를 정의하는 것 (new)
▶ 오버라이딩 : 상속받은 메서드의 내용을 변경하는 것    (change, modify)

ex)
class Parent {
	void parentMethod() {}
}

class Child extends Parent {
	void parentMethod() {}		// 오버라이딩
	void parentMethod(int i) {}	// 오버로딩 (이름이 같은 메서드를 매개변수만 다르게 한)

	void childMethod() {}		// 메서드 정의 
	void childMethod(int i) {}	// 오버로딩 
	void childMethod() {}		// 중복 정의 (error)
}

------------------------------------------------------------------------
* 참조변수 super
- 객체 자신을 가리키는 참조변수. 인스턴스 메서드(생성자)내에서만 존재 (=static메서드 내에서 사용 불가)
- 조상의 멤버를 자신의 멤버와 구별할 때 사용

(this : lv와 iv 구별에 사용, super: 조상 멤버와 자신 멤버 구별에 사용)

Ex1)
class superTest{
   public static void main(String args[]){
	Child c = new Child();
	c.method();
   }
}
class Parent { int x = 10;   /* super.x */ }

class Child extends Parent {
	int x = 20;	     // this.x
	
	void method() {
	   System.out.println("x=" + x);	     // 가까운 x를 가리킴, 20
  	   System.out.println("this.x=" + this.x);   // 20
 	   System.out.println("super.x=" + super.x);  // 10, 조상의 멤버 x를 가리킴
	}
}

Ex2)
class superTest2{
   public static void main(String args[]){
	Child2 c = new Child2();
	c.method();
   }
}
class Parent2 { int x = 10;   /* super.x와 this.x 둘 다 가능 */ }

class Child2 extends Parent2 {
	void method() {
	   System.out.println("x=" + x);	      // 10, 자신 멤버에 x가 없으니 조상 멤버를 가리킴 
  	   System.out.println("this.x=" + this.x);    // 10
 	   System.out.println("super.x=" + super.x);  // 10
	}
}


* super() - 조상의 생성자 	(참조변수 super와 전혀 연관 없음)
- 조상의 생성자를 호출할 때 사용
- 조상의 멤버는 조상의 생성자를 호출해서 초기화

Q. 조상의 생성자를 호출할 일이 있을까요?
A. 있다. 자손 클래스의 생성자에서 조상 클래스의 생성자를 호출할 일이 있다.

ex)
class Point {						class Point3D extends Point {
    int x, y;						    int z;

    Point(int x, int y) {  // 생성자			    Point3D(int x, int y, int z) {
	this.x = x;    // iv 초기화	  ㅡㅡㅡㅡㅡ>		this.x = x;   // 조상의 멤버를 초기화   (비추)
	this.y = y;    // iv 초기화				this.y =  y;   // 조상의 멤버를 초기화   (비추)
    }								this.z = z;
}							    } 
 							}   // 에러는 아니지만 .. 이렇게 하면 안 됨
							 ==> 자손의 생성자는 자기가 선언한 것만 초기화 해야 함. 
- 이렇게 바꾸자! **
Point3D(int x, int y, int z) {
     super(x, y);	// 조상클래스의 생성자 Point(int x, int y)를 '호출'   (조상의 멤버를 초기화 하는 대신)
     this.z = z;	// 자신의 멤버를 초기화 
}
