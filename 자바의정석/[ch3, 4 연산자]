[ch3, 4 연산자]
* 연산자와 피연산자			x + 3
연산자: 연산을 수행하는 기호 		ex) +
피연산자: 연산자의 연산 수행 대상 		ex) x, 3 
==> 모든 연산자는 연산 결과를 반환한다.

* 연산자의 종류
1. 산술 연산자  (+, -, /, % 등)
2. 비교 연산자  ( >, <, >=, <=, ==, !=)
3. 논리 연산자  (&&, ||, ! 등) 그리고(and)와 또는(or)으로 조건을 연결 
4. 대입 연산자  (= ) 우변의 값을 좌변에 저장
5. 기타 	      ((type), ?:, instanceof ) 형변환 연산자, 삼항 연산자, instanceof 연산자

* 연산자의 우선순위
- 하나의 식에 연산자가 둘 이상 있을 때, 어떤 연산을 먼저 수행할지를 자동 결정하는 것
- 수동 결정하고 싶으면 괄호 () 이용

높은 순 								낮은 순
단항 연산자  - 산술 연산자 - 비교 연산자 - 논리 연산자 - 삼항 연산자 - 대입 연산자 

* 연산자의 결합규칙 
우선순위가 같은 연산자가 있을 때, 어떤것을 먼저?

==> 대입과 단항 연산자를 제외하면, 모두 왼쪽 -> 오른쪽
ex) 
1. 3 + 4 - 5		2. x = y = 3
    1번				 1번
	2번 		    2번 

* 우선순위 정리 
1) 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행됨
2) 단항(1) > 이항 (2) > 삼항 (3) . 단항 연산자의 우선순위가 이항 연산자보다 높다.
3) 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽 -> 오른쪽 

----------------------------------------------
* 증감 연산자 
증가 연산자(++) : 피연산자의 값을 1 증가시킨다.
감소 연산자(--) : 피연산자의 값을 1 감소시킨다.

* 종류
전위형 : 값이 참조되기 전에 증가시킨다.	ex) j = ++i; (증가 후에, 참조하여 대입)
후위형 : 값이 참조된 후에 증가시킨다.	ex)j = i++; (참조하여 대입 후에, 증가)

==> 증감 연산자가 독립적(단독적)으로 사용된 경우, 전위형과 후위형의 차이가 없다.

* 형변환 연산자
형변환 : 변수 또는 상수의 타입을 다른 타입으로 변환하는 것 , 형식: (타입)피연산자
형변환을 하는 이유? ==> 서로 다른 두 타입을 일치시키기 위해서 

double d = 85.4;
int score = (int)d;

-> int score = (int)85.4;
-> int score = 85;

* 자동 형변환
float f = 1234;    // int타입의 값을 float타입의 변수에 저장. 형변환이 생략이 된 것임. compiler가 자동으로 넣어준 것! 
  大	     小
int i = 3.14f;	     // error. 
 小	大	   // float가 int보다 큼. 큰 값을 작은 값에 자동 형변환은 불가.
int i = (int)3.14f; // OK!

==> "기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환된다."
그래서 표현 범위가 좁은 타입에서 넓은 타입으로 형변환하는 경우에는 값 손실이 없으므로 두 타입 중에서 표현범위가 더 넓은 쪽으로 형변환된다.
  小			    大
byte short int long float double 
 1     2    4   8     4     8    (byte)

byte b = 100;		//ok. byte타입의 범위(-128 ~ 127)의 값 대입 
byte b = (byte)100; 	// ok. byte 타입으로 형변환하여 대입 

int i = 100;
byte b = i;   		// error. int타입을 byte타입에 대입
byte b = (byte)i; 	 // ok. byte타입으로 형변환하여 대입

byte b = 1000; 		// error. byte타입의 범위(-128 ~ 127)를 벗어난 값 대입 
byte b = (byte)1000; 	// ok. 그러나 값 손실 발생하여 b 값에는 -24가 저장됨

------------------------------------------------
* 산술 변환 
- 연산 전에 피연산자의 타입을 일치시키는 것 

* 규칙 **
1. 두 피연산자의 타입을 같게 일치시킨다. (큰 타입으로 일치)
ex) long + int -> long + long -> long
   float + int -> float + float -> float
   double + float -> double + double -> double

2. 피연산자의 값이 int보다 작은 타입이면 int로 변환된다.
ex) byte + short -> int + int -> int
   char + short -> int + int -> int

----------------------------------------------
* 반올림 - Math.round()
실수를 소수점 첫째 자리에서 반올림한 정수를 반환
	long result = Math.round(4.52); 	 // result에 5가 저장된다.

if 소수점 넷째 자리에서 반올림한 값을 얻고 싶다면? 
==> 1000을 곱해준 다음 메서드 적용하고 다시 1000으로 나눠주면 된다.
ex) 
class Ex3_11{
	public static void main(String arge[]){
		double pi = 3.141592;
		double shortPi = Math.round(pi * 1000) / 1000.0;
		System.out.println(shortPi);
	}
}

과정)
Math.round(pi * 1000) / 1000.0
-> Math.round(3.141592 * 1000) / 1000.0
-> Math.round(3141.592) / 1000.0
-> 3142 / 1000.0
-> 3.142

if 
double pi = 3.141592; // 3.141을 얻으려면?
pi * 1000;		// 3141.592
(int)(pi*1000);		// 3141
(int)(pi*1000)/1000;	// 3	(1000으로 나누면 안됨 소수점을 버리게 되니까)
(int)(pi*1000)/1000.0;  // 3.141

* 나머지 연산자 %
- 오른쪽 피연산자로 나누고 남은 나머지를 반환
- 나누는 피연산자는 0이 아닌 정수만 허용 (부호는 무시됨)
ex)
System.out.println(10 % 8);  // 2 
System.out.println(10 % -8); // 2 (부호 무시)

----------------------------------------------------

* 비교 연산자   > < >= <= == !=
- 두 피연산자를 비교해서 true 또는 false를 반환

* 문자열의 비교 !!!!!!!!!!!!!!!!
- 문자열 비교에는 == 대신 equals() 사용해야 함
ex)
String str1 = "abc";
String str2 = "abc";
System.out.println(str1==str2);			// true
System.out.println(str1.equals(str2));		// true

String str1 = new String("abc");
String str2 = new String("abc");
System.out.println(str1==str2);			// false (new로 생성해서 하는 경우에는 false가 나올 수 있음)
System.out.println(str1.equals(str2));		// true

----------------------------------------------------

* 논리 연산자  %%, ||
- 조건식을 연결할 때 사용하는 연산자 
|| (or결합) : 어느 한쪽만 true여도 true 결과를 얻음
&& (and결합) : 양쪽 모두 true여만 true 결과를 얻음 

ex)
1. x는 10보다 크고 20보다 작다.  
x > 10 && x < 20      혹은   	10 < x && x < 20 

2. i는 2의 배수 또는 3의 배수이다.
i%2==0 || i%3==0
i가 8일 때, 위 식의 결과값은 true 

3. i는 2의 배수 또는 3의 배수지만 6의 배수는 아니다.
( i%2==0 || i%3==0 ) && i%6!=0
	*참고: &&가 || 보다 계산 우선순위가 높아서 먼저 계산되기 때문에 위 식에서 ()괄호가 없으면 안됨.

4. 문자 ch는 숫자 ('0'~'9')이다.
'0' <= ch && ch <= '9'
	*참고: 유니코드에서 문자 '0'부터 '9'까지 연속적으로 배치 돼 있어 가능한 식

5. 문자 ch는 대문자 또는 소문자이다.
('a' <= ch && ch <= 'z') || ('A' <= ch && ch <='Z')
	*참고: 유니코드에서 a부터 z까지, A부터 Z까지 연속으로 배치 돼 있어 가능한 식

* 논리 부정 연산자 ! (단항 연산자)
- true를 false로, false를 true로 바꾼다.

boolean b = true;
!!b -> !!true -> !false -> true 

ex) 문자 ch가 소문자가 아니다
!('a' <= ch && ch <= 'z') 
= !(ch는 소문자) 

-------------------------------------------------------
* 조건 연산자 ? :
- 조건식의 결과에 따라 연산결과를 달리한다.

[ 조건식 ? 식1 : 식2  ] : 	조건식이 참이면 식1, 거짓이면 식2 
result = (x > y) ? x : y; 		// 괄호 생략 가능
==> result는 x>y가 참이면 x, 거짓이면 y

삼항 연산자의 장점: if문을 쓰면 복잡한 코드를 삼항 연산자로 보다 깔끔하고 간편하게 쓸 수 있다.
ex) 
if (x>y)
   result = x;  // x>y가 true일 때
else 
   result = y;  // x>y가 false일 때
==> 
result = (x > y) ? x : y;

* 대입 연산자 =
- 오른쪽 피연산자를 왼쪽 피연산자에 저장 후 저장된 값을 반환
- 대입 연산자의 연산 순서는 '오른쪽 -> 왼쪽'
x = y = 3
       1번
 2번 
- lvalue: 대입 연산자의 왼쪽 피연산자
- rvalue: 대입 연산자의 오른쪽 피연산자 (변수, 배열과 같은 저장 공간)
ex) x = 3
x = lvalue, 3 = rvalue

int i = 0;
3 = i + 3; // error. lvalue가 값을 저장할 수 있는 공간이 아님.
i + 3 = i; // error. lvalue의 연산결과가 리터럴
final int MAX = 3; // 변수 앞에 키워드 final을 붙이면 상수가 된다.
MAX = 10;    // error. 상수에 새로운 값을 저장할 수 없다.

* 복합 대입 연산자 
- 대입 연산자와 다른 연산자를 하나로 축약
i += 3;   ==>  i = i+3; 과 같다.

----------------------------------------------------------
[ch 4 조건문]

*조건문과 반복문 ( = 제어문) 
- 조건문 : 조건을 만족할 때만 {}를 수행 (if, switch문) (0~1번 수행)
- 반복문 : 조건을 만족하는 동안 {}를 수행 (0~n번 실행)

* if 문 
- 조건식이 참일 때, 괄호 {} 안의 문장들을 수행

if(조건식){
	// 조건식이 참일 때 수행될 문장들을 적는다.
}
 
* 조건식의 다양한 예 
- 문자 ch가 'y' 또는 'Y'일 때  
    ch == 'y' || ch == 'Y'
- 문자 ch가 공백이거나 탭 또는 개행 문자일 때
    ch == ' ' || ch == '\t' || ch == '\n'
- 문자 ch가 대문자일 때 
    'A' <= ch && ch <= 'Z'
- 문자 ch가 소문자일 때 
    'a' <= ch && ch <= 'z'
- 문자 ch가 숫자일 때
    '0' <= ch && ch <= '9' 
- 문자열 str의 내용이 "yes"일 때 (대소문자 구분)
   str.equals("yes")
- 문자열 str의 내용이 "yes"일 때 (대소문자 구분안함)
   str.equalsIgnoreCase("yes")

* 블럭 {}
- 여러 문장을 하나로 묶어주는 것
- if문은 괄호를 생략할 수 있음. 하지만 간단한 if문장이 아니면 웬만하면 괄호(블럭)을 생략하지 않는 것이 좋음.
	if(score > 60)
		System.out.println("합격입니다.");//  문장 1. if문에 속한 문장
		System.out.println("합격입니다.");//  문장 2. if문에 속한 문장이 아님 

* if-else문 
- 둘 중의 하나 - 조건식이 참일 때와 거짓일 때로 나눠서 처리 
 if(조건식){
	// 조건식이 참일 때 수행될 문장들을 적는다.
 }else{
	// 조건식이 거짓일 때 수행될 문장들을 적는다.
 }

* if-else if문
- 여러개 중의 하나 - 여러 개의 조건식을 포함한 조건식
 if(조건식1){
	// 조건식1이 참일 때 수행될 문장들을 적는다.
 }else if (조건식 2){
	// 조건식2가 참일 때 수행될 문장들을 적는다.
 }else if (조건식 3){
	// 조건식 3이 참일 때 수행될 문장들으 적는다.
 }else { 	// 마지막은 보통 else블럭으로 끝나며, else 블럭은 생략가능함.
 	// 위의 어느 조건식도 만족하지 않을 때 수행될 문장들을 적는다.
 }

ex) 유저에게 점수를 입력받아 점수에 맞는 학점 출력하는 예제 (psvm코드 생략)

int score = 0;		// 점수를 저장하기 위한 변수
char grade = ' ';	// 학점을 저장하기 위한 변수. 공백으로 초기화함.

System.out.print("점수를 입력하세요.>");
Scanner sc = new Scanner(System.in);
score = sc.nextInt();	// 화면을 통해 입력받은 숫자를 score에 저장

if (score >= 90){
	grade = 'A';
}else if (score >= 80){
	grade = 'B';
}else if (score >= 70){
	grade = 'C';
}else {
	grade = 'D';
}

 System.out.println("당신의 학점은 " + grade + "입니다.");

==> 결과: 
점수를 입력하세요.> 92
당신의 학점은 A입니다.

* 중첩 if문 (if문 안의 if)
if (조건식1) {
	// 조건식1의 결과가 참일 때 수행 될 문장들
	if (조건식2){
		// 조건식1과 조건식2가 모두 참일 때 수행될 문장들 
	}else{
		// 조건식1은 참이고, 조건식2는 거짓일 때 수행될 문장들 
	}
}else{
	// 조건식1의 결과가 거짓일 때 수행될 문장들 
}

---------------------------------------------------------------------
* switch문 
- 처리해야 하는 경우의 수가 많을 때 유용한 조건문

switch (조건식){
	case 값1 : 
	    // 조건식 결과가 값1일 경우 수행될 문장들 
	       // ...
	       break;  // break문을 만나면 switch문을 빠져나온다. ==> break문 빼먹지 않도록 조심
	case 값2 :
	    // 조건식 결과가 값2일 경우 수행될 문장들
	       break;
	default : 
	    // 조건식 결과와 일치하는 case문이 없을 때 수행될 문장들
}

==> break문이 없으면 switch문의 끝까지 모두 실행, default문을 만나고 switch문을  빠져나온다.

* 제약조건
1. switch문의 조건식 결과는 정수 또는 문자열이어야 함
2. case문의 값은 정수, 상수(문자 포함), 문자열만 가능하며, 중복되면 안됨

ex)
int num, result;
final int ONE = 1;
...
switch(result){
	case '1':	// ok. 문자 리터럴 (정수 49와 동일)
	case ONE:	// ok. 정수 상수 
	case "YES":	// ok. 문자열 리터럴. JDK 1.7부터 허용 
 	case num:	// error. 변수는 불가
	case 1.0:	// error. 실수도 불가
}

* case 3: case 4: case 5: 
	System.out.println("현재의 날씨는 봄입니다."); // 이렇게 case 나열하는 것도 가능 

-------------------------------------------------------
* 임의의 정수(실수) 만들기 (=난수)
-  Math.random() 
- 0.0과 1.0사이의 임의의 double값을 반환 

0.0 <= Math.random() < 1.0

ex) 1~3사이의 임의의 정수를 구하고 싶다면?

1. 각 변에 3을 곱한다.
0.0 * 3 <= Math.random() *3 < 1.0 * 3
0.0 <= Math.random() *3 < 3.0

2. 각 변을 int형으로 변환한다.
(int)0.0 <= (int)Math.random() *3 < (int)3.0
0 <= (int)Math.random() *3 < 3			// 범위는 0<=3 (0, 1, 2)

3. 각 변에 1을 더한다. (우리가 원하는 값의 범위는 1~3사이 정수니까) 
0 + 1 <= (int)(Math.random() *3) +1 < 3+1	
1 <= (int)(Math.random() *3) +1 < 4	

==> 만약 주사위 값 중 난수를 원한다면?
Math.random() *3 에서 3 대신 6 곱해주면 됨

quiz 1) 1~10 사이의 난수를 20개 출력하시오.

for(int i=1; i<=20; i++){
	System.out.println( (int)Math.random()*10 +1 ); // 이러면 다 0나옴. 왜? 곱하기 10 하기 전에 형변환해서.
	System.out.println( (int)(Math.random()*10) +1 );
}

quiz 2) -5~5 사이의 난수를 20개 출력하시오.  ( -5,-4,-3,-2,-1,0,1,2,3,4,5 값 총 11개)

for(int i=1; i<=20; i++){
	System.out.println( (int)(Math.random()*11) -5 );	// 범위는 -5<= x <6 
}
-------------------------------------------------
* 반복문
- 반복문은 크게 for문과 while문이 있음. (+ while문에서 파생된 do-while문)

* for문 (반복문 )
- 조건을 만족하는 동안 블럭 {}을 반복 -> ' 반복횟수 '를 알 때 적합 !! 

for (초기화; 조건식; 증감식){
	// 조건식이 참이면 문장 수행 -> 수행 후 증감식으로 이동
}
// 조건식이 거짓이면 for문 빠져나옴 

quiz 1) 1부터 10을 거꾸로 출력하시오.
for( int i = 10; i >= 1; i--){
	System.out.println(i);
}

quiz 2) i는 1부터 10까지, j는 10부터 1까지 출력하시오.
for( int i=1, j=10; i<=10; i++, j--){
	System.out.println( "i=" +i+ ",j=" +j );	// for문 안에서 초기화된 i와 j는 for문 안에서만 사용할 수 있다.
}

==> 결과: i=1, j=10
	 i=2, j=9 .....

* 조건식을 생략하면, true로 간주되어서 무한반복문이 됨
for(;;){
	System.out.println(""); 
}


**** 중첩 for문 ****
- for문 내에 또 다른 for문을 포함시킬 수 있다.

<< 2단부터 9단까지 구구단코드 >>
for(int i=2; i<=9; i++){
   for(int j=1, j<=9, j++){
	System.out.println( i+"*"+j+"="+(i*j));
    }
   System.out.println();   // 각 단 마다 단락 구분해줄 공백 넣어줌
}

<< 별찍기 !!!! 가로 10줄 세로 5줄짜리 별을 중첩 for문을 통해 찍어보자. >>
for (int i=1; i<=5; i++){
   for(int j=1; j<=10; j++){
	System.out.print("*");
   }
   System.out.println();  // 줄바꿈 해주는 공백 넣어줌
}   

<< 별을 이렇게 찍어보자 >>
*
**
***
****
*****
for (int i=1; i<=5; i++){
   for(int j=1; j<=i; j++){		// j<=10을 i<=i로 바꿔줌 (i가 증가할 때 같이 증가하도록)
	System.out.print("*");
   }
   System.out.println();  // 줄바꿈 해주는 공백
}   

------------------------------------------------------------

* while문 (반복문)
- 조건을 만족시키는 동안 블럭{}을 반복 ->  ' 반복 횟수 '  모를 때 !!!

while (조건식){
	// 조건식의 연산결과가 참인 동안, 반복될 문장들
}
==> 즉, 조건식의 연산결과가 거짓이면 문장들은 한 번도 수행되지 않을 수 있다.

for(int i=1; i<=10; i++){					int i = 1; // 초기화
	System.out.println(i);   //              = 	    	while(i<=10){ // 조건식
} 							System.out.println(i);
							i++;	// 증감식 
							}

==> for문과 while문은 100% 서로 호환이 가능하다.
 
quiz 1) 숫자를 입력받아 각 자리수의 합을 계산하는 반복문을 적으시오.
   int num = 0, sum = 0;
   System.out.println("숫자를 입력하세요. 예:12345)>");

   Scanner sc = new Scanner(System.in);
   String tmp = sc.nextLine();
   num = Integer.parseInt(tmp); // 입력받은 문자열(tmp)를 정수로 변환

   while(num>0){		 // 조건식
	sum += num%10;
	num = num/10;	 // 증감식 
   }
   System.out.println("각 자리수의 합:" +sum);

* do-while문
  - 블럭 {} 을 최소한 한 번은 반복하게 되어 있음! -> 사용자 입력받을 때 유용

   do{
       // 조건식의 연산결과가 참일 때 수행될 문장들 (처음 한 번은 무조건 실행)
   }while (조건식);    // 끝에 ';'를 잊지 않도록 주의 

quiz 2) 1~100 사이의 임의의 수를 저장하고, 사용자가 값을 입력하여 저장값을 맞춰보는 프로그램을 작성하시오 

int input = 0, answer = 0;
answer = (int)(Math.random()*100) + 1;
Scanner sc = new Scanner(System.in);

do{
    System.out.print("1과 100사이의 정수를 입력하세요.");
    input = sc.nextInt();
    
    if(input > answer){
       System.out.println("더 작은수로 다시 시도해보세요.");
    }else if(input < answer){
	System.out.println("더 큰 수로 다시 시도해보세요.");
    }
}while(input!=answer); 		// 즉 input과 answer값이 다르다는 블럭값이 참이므로  do{} 안의 문장들을 수행한다.
    System.out.println("정답입니다.");

--------------------------------------------------------------

* break문
- 자신이 포함된 하나의 반복문을 벗어난다.

(실습) 1. 무한 반복문 만든 후 break 문 사용하여 빠져나오도록 만들어보기 
int sum = 0, i = 0;

while(true){
	if(sum>100)
	break;		// 자신이 속한 하나의 반복문을 벗어난다.

    ++i;
  sum += i;
}
System.out.println("i=" + i);
System.out.println("sum=" + sum);

* continue문 
- 자신이 포함된 반복문의 끝으로 이동 -> 다음 반복으로 건너뜀.
- 전체 반복 중에서 특정 조건 시 반복을 건너뛸 때 유용

for(int i=0; i<=10; i++){
	if(i%3==0)
	   continue;	// 조건식이 참이 되어 continue문이 수행되면 블럭의 끝으로 이동함. break문과 달리 반복문을 벗어나지 않는다.
	System.out.print(i);
}

>> 결과: 12457810 (반복문을 수행은 하되, i%3==0이 참일 시 System.out.println(i); 이 문장을 건너뛰어서 3의배수 출력이 안됐음)

* 이름붙은 반복문 
- 반복문에 이름을 붙여서 하나 이상의 반복문을 벗어날 수 있다.
ex) 
Loop1: for(int i=2; i<=9; i++){		// for문에 Loop1이라는 이름을 붙임.
	for(int j=1; j<=9; j++){
	  if(j==5)
		break Loop1;		// if문 뿐만 아니라 Loop1문도 빠져나감
//		break;			// if문만 빠져나가게 됨 
	 System.out.println(i+ "*" +j + "=" + i*j);
	} //end of for i
	System.out.println();
      } // end of Loop1;

>>> 결과: 2*1=2
	 2*2=4
	 2*3=6
	 2*4=8


