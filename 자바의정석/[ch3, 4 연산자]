[ch3, 4 연산자]
* 연산자와 피연산자			x + 3
연산자: 연산을 수행하는 기호 		ex) +
피연산자: 연산자의 연산 수행 대상 		ex) x, 3 
==> 모든 연산자는 연산 결과를 반환한다.

* 연산자의 종류
1. 산술 연산자  (+, -, /, % 등)
2. 비교 연산자  ( >, <, >=, <=, ==, !=)
3. 논리 연산자  (&&, ||, ! 등) 그리고(and)와 또는(or)으로 조건을 연결 
4. 대입 연산자  (= ) 우변의 값을 좌변에 저장
5. 기타 	      ((type), ?:, instanceof ) 형변환 연산자, 삼항 연산자, instanceof 연산자

* 연산자의 우선순위
- 하나의 식에 연산자가 둘 이상 있을 때, 어떤 연산을 먼저 수행할지를 자동 결정하는 것
- 수동 결정하고 싶으면 괄호 () 이용

높은 순 								낮은 순
단항 연산자  - 산술 연산자 - 비교 연산자 - 논리 연산자 - 삼항 연산자 - 대입 연산자 

* 연산자의 결합규칙 
우선순위가 같은 연산자가 있을 때, 어떤것을 먼저?

==> 대입과 단항 연산자를 제외하면, 모두 왼쪽 -> 오른쪽
ex) 
1. 3 + 4 - 5		2. x = y = 3
    1번				 1번
	2번 		    2번 

* 우선순위 정리 
1) 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행됨
2) 단항(1) > 이항 (2) > 삼항 (3) . 단항 연산자의 우선순위가 이항 연산자보다 높다.
3) 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽 -> 오른쪽 

----------------------------------------------
* 증감 연산자 
증가 연산자(++) : 피연산자의 값을 1 증가시킨다.
감소 연산자(--) : 피연산자의 값을 1 감소시킨다.

* 종류
전위형 : 값이 참조되기 전에 증가시킨다.	ex) j = ++i; (증가 후에, 참조하여 대입)
후위형 : 값이 참조된 후에 증가시킨다.	ex)j = i++; (참조하여 대입 후에, 증가)

==> 증감 연산자가 독립적(단독적)으로 사용된 경우, 전위형과 후위형의 차이가 없다.

* 형변환 연산자
형변환 : 변수 또는 상수의 타입을 다른 타입으로 변환하는 것 , 형식: (타입)피연산자
형변환을 하는 이유? ==> 서로 다른 두 타입을 일치시키기 위해서 

double d = 85.4;
int score = (int)d;

-> int score = (int)85.4;
-> int score = 85;

* 자동 형변환
float f = 1234;    // int타입의 값을 float타입의 변수에 저장. 형변환이 생략이 된 것임. compiler가 자동으로 넣어준 것! 
  大	     小
int i = 3.14f;	     // error. 
 小	大	   // float가 int보다 큼. 큰 값을 작은 값에 자동 형변환은 불가.
int i = (int)3.14f; // OK!

==> "기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환된다."
그래서 표현 범위가 좁은 타입에서 넓은 타입으로 형변환하는 경우에는 값 손실이 없으므로 두 타입 중에서 표현범위가 더 넓은 쪽으로 형변환된다.
  小			    大
byte short int long float double 
 1     2    4   8     4     8    (byte)

byte b = 100;		//ok. byte타입의 범위(-128 ~ 127)의 값 대입 
byte b = (byte)100; 	// ok. byte 타입으로 형변환하여 대입 

int i = 100;
byte b = i;   		// error. int타입을 byte타입에 대입
byte b = (byte)i; 	 // ok. byte타입으로 형변환하여 대입

byte b = 1000; 		// error. byte타입의 범위(-128 ~ 127)를 벗어난 값 대입 
byte b = (byte)1000; 	// ok. 그러나 값 손실 발생하여 b 값에는 -24가 저장됨

------------------------------------------------
* 산술 변환 
- 연산 전에 피연산자의 타입을 일치시키는 것 

* 규칙 **
1. 두 피연산자의 타입을 같게 일치시킨다. (큰 타입으로 일치)
ex) long + int -> long + long -> long
   float + int -> float + float -> float
   double + float -> double + double -> double

2. 피연산자의 값이 int보다 작은 타입이면 int로 변환된다.
ex) byte + short -> int + int -> int
   char + short -> int + int -> int

----------------------------------------------
* 반올림 - Math.round()
실수를 소수점 첫째 자리에서 반올림한 정수를 반환
	long result = Math.round(4.52); 	 // result에 5가 저장된다.

if 소수점 넷째 자리에서 반올림한 값을 얻고 싶다면? 
==> 1000을 곱해준 다음 메서드 적용하고 다시 1000으로 나눠주면 된다.
ex) 
class Ex3_11{
	public static void main(String arge[]){
		double pi = 3.141592;
		double shortPi = Math.round(pi * 1000) / 1000.0;
		System.out.println(shortPi);
	}
}

과정)
Math.round(pi * 1000) / 1000.0
-> Math.round(3.141592 * 1000) / 1000.0
-> Math.round(3141.592) / 1000.0
-> 3142 / 1000.0
-> 3.142

if 
double pi = 3.141592; // 3.141을 얻으려면?
pi * 1000;		// 3141.592
(int)(pi*1000);		// 3141
(int)(pi*1000)/1000;	// 3	(1000으로 나누면 안됨 소수점을 버리게 되니까)
(int)(pi*1000)/1000.0;  // 3.141

* 나머지 연산자 %
- 오른쪽 피연산자로 나누고 남은 나머지를 반환
- 나누는 피연산자는 0이 아닌 정수만 허용 (부호는 무시됨)
ex)
System.out.println(10 % 8);  // 2 
System.out.println(10 % -8); // 2 (부호 무시)

----------------------------------------------------

* 비교 연산자   > < >= <= == !=
- 두 피연산자를 비교해서 true 또는 false를 반환

* 문자열의 비교 !!!!!!!!!!!!!!!!
- 문자열 비교에는 == 대신 equals() 사용해야 함
ex)
String str1 = "abc";
String str2 = "abc";
System.out.println(str1==str2);			// true
System.out.println(str1.equals(str2));		// true

String str1 = new String("abc");
String str2 = new String("abc");
System.out.println(str1==str2);			// false (new로 생성해서 하는 경우에는 false가 나올 수 있음)
System.out.println(str1.equals(str2));		// true

----------------------------------------------------

* 논리 연산자  %%, ||
- 조건식을 연결할 때 사용하는 연산자 
|| (or결합) : 어느 한쪽만 true여도 true 결과를 얻음
&& (and결합) : 양쪽 모두 true여만 true 결과를 얻음 

ex)
1. x는 10보다 크고 20보다 작다.  
x > 10 && x < 20      혹은   	10 < x && x < 20 

2. i는 2의 배수 또는 3의 배수이다.
i%2==0 || i%3==0
i가 8일 때, 위 식의 결과값은 true 

3. i는 2의 배수 또는 3의 배수지만 6의 배수는 아니다.
( i%2==0 || i%3==0 ) && i%6!=0
	*참고: &&가 || 보다 계산 우선순위가 높아서 먼저 계산되기 때문에 위 식에서 ()괄호가 없으면 안됨.

4. 문자 ch는 숫자 ('0'~'9')이다.
'0' <= ch && ch <= '9'
	*참고: 유니코드에서 문자 '0'부터 '9'까지 연속적으로 배치 돼 있어 가능한 식

5. 문자 ch는 대문자 또는 소문자이다.
('a' <= ch && ch <= 'z') || ('A' <= ch && ch <='Z')
	*참고: 유니코드에서 a부터 z까지, A부터 Z까지 연속으로 배치 돼 있어 가능한 식

* 논리 부정 연산자 ! (단항 연산자)
- true를 false로, false를 true로 바꾼다.

boolean b = true;
!!b -> !!true -> !false -> true 

ex) 문자 ch가 소문자가 아니다
!('a' <= ch && ch <= 'z') 
= !(ch는 소문자) 

-------------------------------------------------------
* 조건 연산자 ? :
- 조건식의 결과에 따라 연산결과를 달리한다.

[ 조건식 ? 식1 : 식2  ] : 	조건식이 참이면 식1, 거짓이면 식2 
result = (x > y) ? x : y; 		// 괄호 생략 가능
==> result는 x>y가 참이면 x, 거짓이면 y

삼항 연산자의 장점: if문을 쓰면 복잡한 코드를 삼항 연산자로 보다 깔끔하고 간편하게 쓸 수 있다.
ex) 
if (x>y)
   result = x;  // x>y가 true일 때
else 
   result = y;  // x>y가 false일 때
==> 
result = (x > y) ? x : y;

* 대입 연산자 =
- 오른쪽 피연산자를 왼쪽 피연산자에 저장 후 저장된 값을 반환
- 대입 연산자의 연산 순서는 '오른쪽 -> 왼쪽'
x = y = 3
       1번
 2번 
- lvalue: 대입 연산자의 왼쪽 피연산자
- rvalue: 대입 연산자의 오른쪽 피연산자 (변수, 배열과 같은 저장 공간)
ex) x = 3
x = lvalue, 3 = rvalue

int i = 0;
3 = i + 3; // error. lvalue가 값을 저장할 수 있는 공간이 아님.
i + 3 = i; // error. lvalue의 연산결과가 리터럴
final int MAX = 3; // 변수 앞에 키워드 final을 붙이면 상수가 된다.
MAX = 10;    // error. 상수에 새로운 값을 저장할 수 없다.

* 복합 대입 연산자 
- 대입 연산자와 다른 연산자를 하나로 축약
i += 3;   ==>  i = i+3; 과 같다.

----------------------------------------------------------
[ch 4 조건문]

*조건문과 반복문 ( = 제어문) 
- 조건문 : 조건을 만족할 때만 {}를 수행 (if, switch문) (0~1번 수행)
- 반복문 : 조건을 만족하는 동안 {}를 수행 (0~n번 실행)

* if 문 
- 조건식이 참일 때, 괄호 {} 안의 문장들을 수행

if(조건식){
	// 조건식이 참일 때 수행될 문장들을 적는다.
}
 
* 조건식의 다양한 예 
- 문자 ch가 'y' 또는 'Y'일 때  
    ch == 'y' || ch == 'Y'
- 문자 ch가 공백이거나 탭 또는 개행 문자일 때
    ch == ' ' || ch == '\t' || ch == '\n'
- 문자 ch가 대문자일 때 
    'A' <= ch && ch <= 'Z'
- 문자 ch가 소문자일 때 
    'a' <= ch && ch <= 'z'
- 문자 ch가 숫자일 때
    '0' <= ch && ch <= '9' 
- 문자열 str의 내용이 "yes"일 때 (대소문자 구분)
   str.equals("yes")
- 문자열 str의 내용이 "yes"일 때 (대소문자 구분안함)
   str.equalsIgnoreCase("yes")

* 블럭 {}
- 여러 문장을 하나로 묶어주는 것
- if문은 괄호를 생략할 수 있음. 하지만 간단한 if문장이 아니면 웬만하면 괄호(블럭)을 생략하지 않는 것이 좋음.
	if(score > 60)
		System.out.println("합격입니다.");//  문장 1. if문에 속한 문장
		System.out.println("합격입니다.");//  문장 2. if문에 속한 문장이 아님 

* if-else문 
- 둘 중의 하나 - 조건식이 참일 때와 거짓일 때로 나눠서 처리 
 if(조건식){
	// 조건식이 참일 때 수행될 문장들을 적는다.
 }else{
	// 조건식이 거짓일 때 수행될 문장들을 적는다.
 }

* if-else if문
- 여러개 중의 하나 - 여러 개의 조건식을 포함한 조건식
 if(조건식1){
	// 조건식1이 참일 때 수행될 문장들을 적는다.
 }else if (조건식 2){
	// 조건식2가 참일 때 수행될 문장들을 적는다.
 }else if (조건식 3){
	// 조건식 3이 참일 때 수행될 문장들으 적는다.
 }else { 	// 마지막은 보통 else블럭으로 끝나며, else 블럭은 생략가능함.
 	// 위의 어느 조건식도 만족하지 않을 때 수행될 문장들을 적는다.
 }

ex) 유저에게 점수를 입력받아 점수에 맞는 학점 출력하는 예제 (psvm코드 생략)

int score = 0;		// 점수를 저장하기 위한 변수
char grade = ' ';	// 학점을 저장하기 위한 변수. 공백으로 초기화함.

System.out.print("점수를 입력하세요.>");
Scanner sc = new Scanner(System.in);
score = sc.nextInt();	// 화면을 통해 입력받은 숫자를 score에 저장

if (score >= 90){
	grade = 'A';
}else if (score >= 80){
	grade = 'B';
}else if (score >= 70){
	grade = 'C';
}else {
	grade = 'D';
}

 System.out.println("당신의 학점은 " + grade + "입니다.");

==> 결과: 
점수를 입력하세요.> 92
당신의 학점은 A입니다.

* 중첩 if문 (if문 안의 if)
