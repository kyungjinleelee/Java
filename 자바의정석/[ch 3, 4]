[ch3, 4 연산자]
* 연산자와 피연산자			x + 3
연산자: 연산을 수행하는 기호 		ex) +
피연산자: 연산자의 연산 수행 대상 		ex) x, 3 
==> 모든 연산자는 연산 결과를 반환한다.

* 연산자의 종류
1. 산술 연산자  (+, -, /, % 등)
2. 비교 연산자  ( >, <, >=, <=, ==, !=)
3. 논리 연산자  (&&, ||, ! 등) 그리고(and)와 또는(or)으로 조건을 연결 
4. 대입 연산자  (= ) 우변의 값을 좌변에 저장
5. 기타 	      ((type), ?:, instanceof ) 형변환 연산자, 삼항 연산자, instanceof 연산자

* 연산자의 우선순위
- 하나의 식에 연산자가 둘 이상 있을 때, 어떤 연산을 먼저 수행할지를 자동 결정하는 것
- 수동 결정하고 싶으면 괄호 () 이용

높은 순 								낮은 순
단항 연산자  - 산술 연산자 - 비교 연산자 - 논리 연산자 - 삼항 연산자 - 대입 연산자 

* 연산자의 결합규칙 
우선순위가 같은 연산자가 있을 때, 어떤것을 먼저?

==> 대입과 단항 연산자를 제외하면, 모두 왼쪽 -> 오른쪽
ex) 
1. 3 + 4 - 5		2. x = y = 3
    1번				 1번
	2번 		    2번 

* 우선순위 정리 
1) 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행됨
2) 단항(1) > 이항 (2) > 삼항 (3) . 단항 연산자의 우선순위가 이항 연산자보다 높다.
3) 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽 -> 오른쪽 

----------------------------------------------
* 증감 연산자 
증가 연산자(++) : 피연산자의 값을 1 증가시킨다.
감소 연산자(--) : 피연산자의 값을 1 감소시킨다.

* 종류
전위형 : 값이 참조되기 전에 증가시킨다.	ex) j = ++i; (증가 후에, 참조하여 대입)
후위형 : 값이 참조된 후에 증가시킨다.	ex)j = i++; (참조하여 대입 후에, 증가)

==> 증감 연산자가 독립적(단독적)으로 사용된 경우, 전위형과 후위형의 차이가 없다.

* 형변환 연산자
형변환 : 변수 또는 상수의 타입을 다른 타입으로 변환하는 것 , 형식: (타입)피연산자
형변환을 하는 이유? ==> 서로 다른 두 타입을 일치시키기 위해서 

double d = 85.4;
int score = (int)d;

-> int score = (int)85.4;
-> int score = 85;

* 자동 형변환
float f = 1234;    // int타입의 값을 float타입의 변수에 저장. 형변환이 생략이 된 것임. compiler가 자동으로 넣어준 것! 
  大	     小
int i = 3.14f;	     // error. 
 小	大	   // float가 int보다 큼. 큰 값을 작은 값에 자동 형변환은 불가.
int i = (int)3.14f; // OK!

==> "기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환된다."
그래서 표현 범위가 좁은 타입에서 넓은 타입으로 형변환하는 경우에는 값 손실이 없으므로 두 타입 중에서 표현범위가 더 넓은 쪽으로 형변환된다.
  小			    大
byte short int long float double 
 1     2    4   8     4     8    (byte)

byte b = 100;		//ok. byte타입의 범위(-128 ~ 127)의 값 대입 
byte b = (byte)100; 	// ok. byte 타입으로 형변환하여 대입 

int i = 100;
byte b = i;   		// error. int타입을 byte타입에 대입
byte b = (byte)i; 	 // ok. byte타입으로 형변환하여 대입

byte b = 1000; 		// error. byte타입의 범위(-128 ~ 127)를 벗어난 값 대입 
byte b = (byte)1000; 	// ok. 그러나 값 손실 발생하여 b 값에는 -24가 저장됨

------------------------------------------------
* 산술 변환 
- 연산 전에 피연산자의 타입을 일치시키는 것 

* 규칙 **
1. 두 피연산자의 타입을 같게 일치시킨다. (큰 타입으로 일치)
ex) long + int -> long + long -> long
   float + int -> float + float -> float
   double + float -> double + double -> double

2. 피연산자의 값이 int보다 작은 타입이면 int로 변환된다.
ex) byte + short -> int + int -> int
   char + short -> int + int -> int

----------------------------------------------
* 반올림 - Math.round()
실수를 소수점 첫째 자리에서 반올림한 정수를 반환
	long result = Math.round(4.52); 	 // result에 5가 저장된다.

if 소수점 넷째 자리에서 반올림한 값을 얻고 싶다면? 
==> 1000을 곱해준 다음 메서드 적용하고 다시 1000으로 나눠주면 된다.
ex) 
class Ex3_11{
	public static void main(String arge[]){
		double pi = 3.141592;
		double shortPi = Math.round(pi * 1000) / 1000.0;
		System.out.println(shortPi);
	}
}

과정)
Math.round(pi * 1000) / 1000.0
-> Math.round(3.141592 * 1000) / 1000.0
-> Math.round(3141.592) / 1000.0
-> 3142 / 1000.0
-> 3.142

if 
double pi = 3.141592; // 3.141을 얻으려면?
pi * 1000;		// 3141.592
(int)(pi*1000);		// 3141
(int)(pi*1000)/1000;	// 3	(1000으로 나누면 안됨 소수점을 버리게 되니까)
(int)(pi*1000)/1000.0;  // 3.141

* 나머지 연산자 %
- 오른쪽 피연산자로 나누고 남은 나머지를 반환
- 나누는 피연산자는 0이 아닌 정수만 허용 (부호는 무시됨)
ex)
System.out.println(10 % 8);  // 2 
System.out.println(10 % -8); // 2 (부호 무시)

----------------------------------------------------

* 비교 연산자   > < >= <= == !=
- 두 피연산자를 비교해서 true 또는 false를 반환

* 문자열의 비교 !!!!!!!!!!!!!!!!
- 문자열 비교에는 == 대신 equals() 사용해야 함
ex)
String str1 = "abc";
String str2 = "abc";
System.out.println(str1==str2);			// true
System.out.println(str1.equals(str2));		// true

String str1 = new String("abc");
String str2 = new String("abc");
System.out.println(str1==str2);			// false (new로 생성해서 하는 경우에는 false가 나올 수 있음)
System.out.println(str1.equals(str2));		// true

----------------------------------------------------
