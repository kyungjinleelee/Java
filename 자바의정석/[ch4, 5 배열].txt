[ch4, 5]
[ch4 배열]

* 배열이란?
- 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것 

* 배열의 선언과 생성 
- 배열의 선언 : 배열을 다루기 위한 참조변수의 선언 . (배열을 선언하는 것은 변수 선언이랑은 다름, 변수는 선언하자마자 저장공간이 만들어지지만 배열						은 아님 )
- 선언 방법 : 
타입[] 변수이름;	ex) int[] score;	// 자바에서는 주로 이 방식으로 씀
타입 변수이름[];	ex) int score[];

타입[] 변수이름; 		// 배열을 선언 (배열을 다루기 위한 참조변수 선언)
변수이름 = new 타입[길이]; // 배열을 생성 (실제 저장공간을 생성) 

ex)
int[] score;		  // int 타입의 배열을 다루기 위한 참조변수 score 선언
score = new int[5];	  // int 타입의 값 5개를 저장할 수 있는 배열 생성
int[] score = new int[5];  // 선언과 생성을 동시에 할 수도 있음!

* 배열의 인덱스
- 배열의 인덱스 : 각 요소(저장공간)에 자동으로 붙는 일련번호
- 인덱스의 범위는 0부터 '배열길이-1' 까지.

score[3] = 100;       // 배열 score의 4번째 요소에 100을 저장한다.
int value = score[3]; // 배열 score의 4번째 요소의 값을 읽어서 value에 저장한다.

-----------------------------------------------------------
* 배열의 길이 (int형 상수)
- 배열이름.length 
int[] arr = new int[5];	// 길이가 5인 int 배열의 선언 + 생성 
int tmp = arr.length;	// arr.length의 값은 5이고 tmp에 5가 저장된다.


" 배열은 한번 생성하면 그 길이를 바꿀 수 없다. "

의문 1)) 왜 못바꾸나?
배열은 연속적이어야 해서, 메모리 안의 연속된 공간을 찾아 배열을 생성한다. 추후 공간을 더 할당하고 싶어도 배열은 연속되어야 하기 때문에 이미 생성된 배열의 연속적인 부분이 비어있을 거라는 보장이 없다.

의문 2)) 그럼 길이가 부족하면 어떻게 할 것인가?
따라서 배열의 길이를 바꾸고 싶으면 아예 새로 큰걸 만들어서 기존 것을 복사하고 저장하던지 그렇게 해야함.

* 배열의 모든 요소 출력
int[] score = new int[6];

for( int i=0; i <= score.length; i++){	// 위의 score 배열 길이가 달라져도 for문 내의 조건식을 변경하지 않아도 됨.
	System.out.println(score[i]);
}

* 배열의 초기화
 - 배열의 각 요소에 처음으로 값을 저장하는 것 
int[] score = new int[5];	     // 길이가 5인 int형 배열을 생성
score[0] = 50;
score[1] = 60;
score[2] = 70;
score[3] = 80;
score[4] = 90;		     // 각 요소에 직접 값을 저장한다. = 배열의 초기화


- 위 로직을 반복문을 이용해서 간단하게 초기화시킬 수도 있다.
   for(int i=0; i<=score.length; i++){
	score[i] = i * 10 + 50;

- 그러나 위의 로직은 반드시 규칙이 있어야만 적용 가능하다.
- 더 간단한 방법은?
int[] score = new int[]{50, 60, 70, 80, 90};
int[] score = {50, 60, 70, 80, 90};   // new int[]를 생략할 수도 있음, (그래서 99% 이 방법을 쓴다), 하지만 반드시 이 한문장으로 써야함

----------------------------------------------------------------------
* 배열의 출력
int[] iArr = { 100, 95, 80, 70, 60};

System.out.println(iArr); // 이렇게 출력하면? 
==> 배열을 가리키는 참조변수 iArr의 값을 출력한다. 즉 [I@14318bb와 같은 형식의 문자열이 출력됨.

 - but 예외!
 char[] chArr = {'a', 'b', 'c', 'd'}; 	// 캐릭터 배열 char 일 때는 예외다.
 System.out.println(chArr); // abcd가 출력됨.

==> 즉 배열의 모든 요소를 출력하려면 for문을 써야함.
for(int i=0; i < iArr.length; i++){
	System.out.println(iArr[i]);
}

==> 배열 출력의 또 다른 방법! - Arrays.toString

System.out.println(Arrays.toString(iArr)); 	// 배열 iArr의 모든 요소를 출력한다. [100, 95, 80, 70, 60]이 출력
- 한 줄로 출력할 수 있어 편리하기에 이 방법을 많이 쓴다.
- Arrays import 해줘야함

int[] iArr1 = new int[10];
EX 1) 1~10의 숫자를 순서대로 배열하시오.
for(int i=0; i<=iArr1.length; i++){
	iArr[i] = i+1;
}

int[] iArr2 = new int[10];
ex 2) 1~10 사이의 난수로 배열을 채우시오.
for(int i=0; i<=iArr2.length; i++){
	iArr2[i] = (int)(Math.random()*10)+1;

--------------------------------------------------------------------
* 배열의 활용 

1. 배열의 모든 요소를 더해서 총합과 평균을 구하시오.
int sum = 0;		// 총합을 저장하기 위한 변수 
flaot average = 0f;	// 평균을 저장하기 위한 변수

int[] score = {100,88,100,100,90};

for(int i=0; i<score.length; i++){	// <=면 안되고 < 여야함. 배열의 길이는 4까지 밖에 없으니까!
	sum += score[i];
}

average = sum / score.length;		// 이러면 틀림 
average = sum / (float)score.length; 	// 계산 결과를 float 타입으로 얻으려 형변환

System.out.println(sum);	// 478 (총합)
System.out.println(average);	// 95.6 (평균)

2. 배열의 요소 중에서 제일 큰 값과 제일 작은 값을 찾는다.
int[] score = {79, 88, 91, 33, 100, 55, 95};

int max = score[0];	// 배열의 첫 번째 값으로 최대값을 초기화
int min = socre[0];	// 배열의 첫 번째 값으로 최소값을 초기화

for(i = 1; i<score.length; i++){		// i=0;부터 시작할 필요 없음, 이미 배열의 첫 번째 값으로 초기화 마쳤으니까
	if(max < score[i]){
		max = score[i];
	} else if (score[i] < min){
		min = score[i];
	}
}



