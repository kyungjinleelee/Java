[ch 6 객체지향] **중요

* 객체지향 언어
'80년 초 소프트웨어의 위기 - 빠른 변화를 못 쫓아감
해결책으로 객체지향 언어를 도입 (절차적 -> 객체지향)

객체지향 언어 = 기존의 프로그래밍 언어에 + 객체지향개념(규칙)이 추가된 것일 뿐임 ! 
-> '코드의 재사용성이 높고 유지보수가 용이, 중복 코드 제거' 를 위해

* oop (object-oriented programming) (=객체 지향 프로그래밍)의  4가지 핵심 개념  // 캡상추다 ㅎㅎ..
1. 캡슐화
2. 상속
3. 추상화
4. 다형성 (*중요)

* 클래스와 객체
<클래스>
- 클래스: 객체를 정의해 놓은 것 (객체는 이러이러하다는 걸 설명해놓은 것) ( = 설계도.)
- 용도: 클래스는 객체를 생성하는데 사용 

<객체>
- 객체: 실제로 존재하는 것. 사물 또는 개념			     ( = 제품.)
- 용도: 객체가 가지고 있는 기능과 속성에 따라 다름 

ex)
클래스: 제품 설계도, tv 설계도, 붕어빵 기계
객체   : 제품         , tv      , 붕어빵

Q. 설계도를 왜 만들어요 ?
A. 제품을 쉽게 만들려고! 한번 만들어놓으면 다음에 만들 때 편하니까.

---------------------------------------------------------------
* 객체의 구성요소 - 속성과 기능
실제 세계를 어떻게 하면 컴퓨터 안으로 옮겨놓을까? 에서 부터 나온 고민들.
TV라는 Hardward를 software로 만들어서 컴퓨터 안으로 설치 > 컴퓨터 안에서 tv보듯이 할 수 있는 것. (hardward를 softward화)

Q. Hardware를 software로 바꾸려면 어떻게 해야대여?
A. Hardware를 분석 & 관찰 해야합니다. 어떻게 해야 software화 할까? (=어떻게 해야 프로그램화 할 수 있을까?)

"' 객체 = 속성(변수) + 기능(메서드) '"

ex)
속성: 크기, 길이, 높이, 색상, 볼륨, 채널 등 			// 변수
기능: 켜기, 끄기, 볼륨 높이기, 볼륨 낮추기. 채널 변경하기 등 	// 메서드

class TV {
    String color;    // 색깔 
    boolean power;   // 전원상태
    int channel;     // 채널

void power()	   { power = !power; }
void channelUp()   { channel++;}
void channelDown() { channel--;}
}

* 객체와 인스턴스
- 객체: 모든 인스턴스를 대표하는 일반적 용어
- 인스턴스: 특정 클래스로부터 생성된 객체 (ex: TV 인스턴스)
- 인스턴스화: 앞에서 말한 설계도를 가지고 제품을 만드는 걸 '인스턴스화'라고 함.

	  인스턴스화
클래스 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ> 인스턴스 (객체)


* 정리 ! 
 q. 클래스가 왜 필요한가?
 a. 객체를 생성하기 위해 

 q. 객체는 왜 필요한가?	(이 말인즉, tv는 왜 필요한가?)
 a. 객체를 사용하기 위해 	(tv 볼려고!)

 q. 객체를 사용한다는 것은?
 a. 객체가 가진 속성과 기능을 사용하는 것  

---------------------------------------------------------------------
* 하나의 소스파일에 여러 클래스 작성
- 하나의 소스파일에는 하나의 클래스만 작성하는 것이 바람직 
- 하나의 소스파일에 public가 하나도 없는건 가능, 하지만 두 개 이상은 불가능 
<< 옳은 예 >>
 1. public class가 있는 경우, 소스파일의 이름은 반드시 public class의 이름과 일치해야 한다.
 ex) Hello2.java
 public class Hello2 {}
      class Hello3 {}

 2. public class가 없을 때는, 소스파일의 이름은 Hello2.java, Hello3.java 둘 다 가능하다.
 ex) Hello2.java
   class Hello2 {}
  class Hello3 {}

<< 틀린 예 >>
 1. 하나의 소스파일에 둘 이상의 public class가 존재하면 안된다. 
 각 클래스를 별도의 소스파일에 나눠서 저장하던가/ 둘 중의 한 클래스에 public을 붙이지 않아야 한다.
 ex) Hello2.java
 public class Hello2 {}
 public class Hello3 {} XXXXX

 2. 소스파일의 이름과 public class의 이름이 일치하지 않는다. 대소문자를 구분하므로 대소문자까지 일치해야한다.
 ex) hello2.java
 public class Hello2 {}
        class Hello3 {} 
 ==> 소스파일의 이름에서 'h'를 'H'로 변경해야한다.
---------------------------------------------------------------------

* 객체의 생성과 사용 (객체를 다루려면 참조변수가 있어야 함 **)

1. 객체의 생성 
	클래스명 변수명;		// 클래스의 객체를 참조하기 위한 참조변수를 선언
	변수명 = new 클래스명();	// 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장

Tv t;			// Tv 클래스 타입의 참조변수 t를 선언 ①
t = new TV(); 		// Tv 인스턴스를 생성한 후, 생성된 Tv 인스턴스의 주소를 t에 저장 ②, ③
==> 참조변수 = 리모콘.  ** tv 를 다루려면 리모콘이 있어야 함 = 객체를 다루려면 참조변수가 있어야 함 **

[순서] ① 참조변수 먼저 선언  >  ② 객체 생성  >  ③ 연결 

Tv t;			
t = new TV(); // 이 두 문장을 하나로 합치면? 	Tv t = new Tv(); 


2. 객체의 사용 
- 객체가 가지고 있는 변수, 메서드를 사용한다는 의미

t.channel = 7;		// Tv인스턴스의 멤버변수 channel의 값을 7로 설정
t.channelDown();	// Tv인스턴스의 메서드 channelDown()을 호출		(참조변수 t가 가르키는 객체에 channelDown() 메서드 호출)
System.out.println("현재 채널은" + t.channel + "입니다.");		// channelDown()메서드 적용되어 6 출력

1) 클래스 작성 		// 설계도 작성
2) 객체 생성 		// 제품 만들기
3) 객체 사용 		// 객체가 가지고 있는 변수, 메서드 사용
의 루트로 간다.

* 객체의 생성과 사용 
- 하나의 인스턴스를 여러 개의 참조변수가 가리키는 경우 (가능)
- 여러 인스턴스를 하나의 참조변수가 가리키는 경우 (불가능)

예제! >> 
class Example{
   public static void main(String args[]){
	Tv t;
	t = new Tv();
	t.channel = 7;
	t.channelDown();
	System.out.println("현재 채널은" + t.channel + "입니다.");		
   }
}

class Tv{
   // Tv의 속성 (멤버변수)
   String color;	// 색상
   boolean power;	// 전원 상태 (on/off)
   int channel;		// 채널

     // Tv의 기능 (메서드)
   void power() { power = !power;}	// tv를 켜거나 끄는 기능을 하는 메서드
   void channelUp() { ++channel; }	// tv의 채널을 높이는 기능을 하는 메서드 
   void channelDown() { --channel; }	// tv의 채널을 낮추는 기능을 하는 메서드

}

==> 실행하면 "현재 채널은 6입니다." 가 출력 

-----------------------------------------------------------------
* 객체 배열 
객체 배열 == 참조변수 배열

ex) Tv 타입의 참조변수 tv1, tv2, tv3가 있을 때, 이걸 배열로 바꾸면 ?
Tv tv1, tv2, tv3;  ----->  Tv[] tvArr = new Tv[3];

// 객체를 생성해서 배열의 각 요소에 저장
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();


Tv[] tvArr = new Tv[3];
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv(); 		
==> 객체 배열은 단순한 참조변수 배열이기 때문에, 객체를 만든 후 채워 넣어주어야 함. 객체를 만들었다고 해서 자동으로 들어가는 게 아님! 

------------------------------------------------------------
* 클래스의 정의 
1. 설계도 
2. 데이터와 함수의 결합
3. 사용자 정의 타입 

- 발전 루트 : 변수 > 배열 > 구조체 > 클래스
변수    : 하나의 데이터를 저장할 수 있는 공간 
배열    : 같은 종류의 여러 데이터를 하나로 저장할 수 있는 공간
구조체 : 서로 관련된 여러 데이터(종류 상관x)를 하나로 저장할 수 있는 공간
클래스 : 데이터와 함수(=메서드)의 결합 (구조체 + 함수)

* 사용자 정의 타입 
- 원하는 타입을 직접 만들 수 있다.
class Time{
	int hour;
	int minute;
	int second;
}

즉,
int hour= 12;			 Time t = new Time();
int minute= 34;		= 	 t.hour = 12;
int second= 56; 			  t.minute = 34;
				 t.second = 56; 
=> 위 두 코드는 똑같다. 
하지만 왼쪽 코드보다는 오른쪽처럼 작성해야 유지보수도 쉽고, 서로 관련된 코드들을 강하게 묶을 수 있으며, 코드가 덜 복잡해 진다. 
---------------------------------------------------------------

* 선언 위치에 따른 변수의 종류
	클래스 영역 (에 선언된 변수는 iv, cv )/ 선언문만 가능 
영역 [
	메서드 영역 (에 선언된 변수는 lv)

cv(class variable) : 클래스 변수 (iv 앞에다 static 붙인 것), 클래스가 메모리에 올라갈 때 생성 (클래스가 필요할 때 메모리에 올라감)
		     아무때나 쓸 수 있음 (자동으로 생성됨)
iv(instance variable): 인스턴스 변수 , 인스턴스가 생성됐을 때 생성 *** -> 객체 생성을 한 후에 쓸 수 있음
lv(local variable): 지역변수 , 변수 선언문이 수행되었을 때 생성 , 메서드 끝날 때까지 있다가 종료 시 자동 제거됨 

==> 객체는 ,철저하게 프로그래밍 관점으로만 봤을 때, " iv(변수)를 여러개 묶어놓은 것 " 그 이상 그 이하도 아님.

*클래스 변수와 인스턴스 변수

