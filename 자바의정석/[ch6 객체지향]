[ch 6 객체지향] **중요

* 객체지향 언어
'80년 초 소프트웨어의 위기 - 빠른 변화를 못 쫓아감
해결책으로 객체지향 언어를 도입 (절차적 -> 객체지향)

객체지향 언어 = 기존의 프로그래밍 언어에 + 객체지향개념(규칙)이 추가된 것일 뿐임 ! 
-> '코드의 재사용성이 높고 유지보수가 용이, 중복 코드 제거' 를 위해

* oop (object-oriented programming) (=객체 지향 프로그래밍)의  4가지 핵심 개념  // 캡상추다 ㅎㅎ..
1. 캡슐화
2. 상속
3. 추상화
4. 다형성 (*중요)

* 클래스와 객체
<클래스>
- 클래스: 객체를 정의해 놓은 것 (객체는 이러이러하다는 걸 설명해놓은 것) ( = 설계도.)
- 용도: 클래스는 객체를 생성하는데 사용 

<객체>
- 객체: 실제로 존재하는 것. 사물 또는 개념			     ( = 제품.)
- 용도: 객체가 가지고 있는 기능과 속성에 따라 다름 

ex)
클래스: 제품 설계도, tv 설계도, 붕어빵 기계
객체   : 제품         , tv      , 붕어빵

Q. 설계도를 왜 만들어요 ?
A. 제품을 쉽게 만들려고! 한번 만들어놓으면 다음에 만들 때 편하니까.

---------------------------------------------------------------
* 객체의 구성요소 - 속성과 기능
실제 세계를 어떻게 하면 컴퓨터 안으로 옮겨놓을까? 에서 부터 나온 고민들.
TV라는 Hardward를 software로 만들어서 컴퓨터 안으로 설치 > 컴퓨터 안에서 tv보듯이 할 수 있는 것. (hardward를 softward화)

Q. Hardware를 software로 바꾸려면 어떻게 해야대여?
A. Hardware를 분석 & 관찰 해야합니다. 어떻게 해야 software화 할까? (=어떻게 해야 프로그램화 할 수 있을까?)

"' 객체 = 속성(변수) + 기능(메서드) '"

ex)
속성: 크기, 길이, 높이, 색상, 볼륨, 채널 등 			// 변수
기능: 켜기, 끄기, 볼륨 높이기, 볼륨 낮추기. 채널 변경하기 등 	// 메서드

class TV {
    String color;    // 색깔 
    boolean power;   // 전원상태
    int channel;     // 채널

void power()	   { power = !power; }
void channelUp()   { channel++;}
void channelDown() { channel--;}
}

* 객체와 인스턴스
- 객체: 모든 인스턴스를 대표하는 일반적 용어
- 인스턴스: 특정 클래스로부터 생성된 객체 (ex: TV 인스턴스)
- 인스턴스화: 앞에서 말한 설계도를 가지고 제품을 만드는 걸 '인스턴스화'라고 함.

	  인스턴스화
클래스 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ> 인스턴스 (객체)


* 정리 ! 
 q. 클래스가 왜 필요한가?
 a. 객체를 생성하기 위해 

 q. 객체는 왜 필요한가?	(이 말인즉, tv는 왜 필요한가?)
 a. 객체를 사용하기 위해 	(tv 볼려고!)

 q. 객체를 사용한다는 것은?
 a. 객체가 가진 속성과 기능을 사용하는 것  

---------------------------------------------------------------------
* 하나의 소스파일에 여러 클래스 작성
- 하나의 소스파일에는 하나의 클래스만 작성하는 것이 바람직 
- 하나의 소스파일에 public가 하나도 없는건 가능, 하지만 두 개 이상은 불가능 
<< 옳은 예 >>
 1. public class가 있는 경우, 소스파일의 이름은 반드시 public class의 이름과 일치해야 한다.
 ex) Hello2.java
 public class Hello2 {}
      class Hello3 {}

 2. public class가 없을 때는, 소스파일의 이름은 Hello2.java, Hello3.java 둘 다 가능하다.
 ex) Hello2.java
   class Hello2 {}
  class Hello3 {}

<< 틀린 예 >>
 1. 하나의 소스파일에 둘 이상의 public class가 존재하면 안된다. 
 각 클래스를 별도의 소스파일에 나눠서 저장하던가/ 둘 중의 한 클래스에 public을 붙이지 않아야 한다.
 ex) Hello2.java
 public class Hello2 {}
 public class Hello3 {} XXXXX

 2. 소스파일의 이름과 public class의 이름이 일치하지 않는다. 대소문자를 구분하므로 대소문자까지 일치해야한다.
 ex) hello2.java
 public class Hello2 {}
        class Hello3 {} 
 ==> 소스파일의 이름에서 'h'를 'H'로 변경해야한다.
---------------------------------------------------------------------

* 객체의 생성과 사용 (객체를 다루려면 참조변수가 있어야 함 **)

1. 객체의 생성 
	클래스명 변수명;		// 클래스의 객체를 참조하기 위한 참조변수를 선언
	변수명 = new 클래스명();	// 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장

Tv t;			// Tv 클래스 타입의 참조변수 t를 선언 ①
t = new TV(); 		// Tv 인스턴스를 생성한 후, 생성된 Tv 인스턴스의 주소를 t에 저장 ②, ③
==> 참조변수 = 리모콘.  ** tv 를 다루려면 리모콘이 있어야 함 = 객체를 다루려면 참조변수가 있어야 함 **

[순서] ① 참조변수 먼저 선언  >  ② 객체 생성  >  ③ 연결 

Tv t;			
t = new TV(); // 이 두 문장을 하나로 합치면? 	Tv t = new Tv(); 


2. 객체의 사용 
- 객체가 가지고 있는 변수, 메서드를 사용한다는 의미

t.channel = 7;		// Tv인스턴스의 멤버변수 channel의 값을 7로 설정
t.channelDown();	// Tv인스턴스의 메서드 channelDown()을 호출		(참조변수 t가 가르키는 객체에 channelDown() 메서드 호출)
System.out.println("현재 채널은" + t.channel + "입니다.");		// channelDown()메서드 적용되어 6 출력

1) 클래스 작성 		// 설계도 작성
2) 객체 생성 		// 제품 만들기
3) 객체 사용 		// 객체가 가지고 있는 변수, 메서드 사용
의 루트로 간다.

* 객체의 생성과 사용 
- 하나의 인스턴스를 여러 개의 참조변수가 가리키는 경우 (가능)
- 여러 인스턴스를 하나의 참조변수가 가리키는 경우 (불가능)

예제! >> 
class Example{
   public static void main(String args[]){
	Tv t;
	t = new Tv();
	t.channel = 7;
	t.channelDown();
	System.out.println("현재 채널은" + t.channel + "입니다.");		
   }
}

class Tv{
   // Tv의 속성 (멤버변수)
   String color;	// 색상
   boolean power;	// 전원 상태 (on/off)
   int channel;		// 채널

     // Tv의 기능 (메서드)
   void power() { power = !power;}	// tv를 켜거나 끄는 기능을 하는 메서드
   void channelUp() { ++channel; }	// tv의 채널을 높이는 기능을 하는 메서드 
   void channelDown() { --channel; }	// tv의 채널을 낮추는 기능을 하는 메서드

}

==> 실행하면 "현재 채널은 6입니다." 가 출력 

-----------------------------------------------------------------
* 객체 배열 
객체 배열 == 참조변수 배열

ex) Tv 타입의 참조변수 tv1, tv2, tv3가 있을 때, 이걸 배열로 바꾸면 ?
Tv tv1, tv2, tv3;  ----->  Tv[] tvArr = new Tv[3];

// 객체를 생성해서 배열의 각 요소에 저장
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();


Tv[] tvArr = new Tv[3];
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv(); 		
==> 객체 배열은 단순한 참조변수 배열이기 때문에, 객체를 만든 후 채워 넣어주어야 함. 객체를 만들었다고 해서 자동으로 들어가는 게 아님! 

------------------------------------------------------------
* 클래스의 정의 
1. 설계도 
2. 데이터와 함수의 결합
3. 사용자 정의 타입 

- 발전 루트 : 변수 > 배열 > 구조체 > 클래스
변수    : 하나의 데이터를 저장할 수 있는 공간 
배열    : 같은 종류의 여러 데이터를 하나로 저장할 수 있는 공간
구조체 : 서로 관련된 여러 데이터(종류 상관x)를 하나로 저장할 수 있는 공간
클래스 : 데이터와 함수(=메서드)의 결합 (구조체 + 함수)

* 사용자 정의 타입 
- 원하는 타입을 직접 만들 수 있다.
class Time{
	int hour;
	int minute;
	int second;
}

즉,
int hour= 12;			 Time t = new Time();
int minute= 34;		= 	 t.hour = 12;
int second= 56; 			  t.minute = 34;
				 t.second = 56; 
=> 위 두 코드는 똑같다. 
하지만 왼쪽 코드보다는 오른쪽처럼 작성해야 유지보수도 쉽고, 서로 관련된 코드들을 강하게 묶을 수 있으며, 코드가 덜 복잡해 진다. 
---------------------------------------------------------------

* 선언 위치에 따른 변수의 종류
	클래스 영역 (에 선언된 변수는 iv, cv )/ 선언문만 가능 
영역 [
	메서드 영역 (에 선언된 변수는 lv)

cv(class variable) : 클래스 변수 (iv 앞에다 static 붙인 것), 클래스가 메모리에 올라갈 때 생성 (클래스가 필요할 때 메모리에 올라감)
		     아무때나 쓸 수 있음 (자동으로 생성됨)
iv(instance variable): 인스턴스 변수 , 인스턴스가 생성됐을 때 생성 *** -> 객체 생성을 한 후에 쓸 수 있음
lv(local variable): 지역변수 , 변수 선언문이 수행되었을 때 생성 , 메서드 끝날 때까지 있다가 종료 시 자동 제거됨 

==> 객체는 ,철저하게 프로그래밍 관점으로만 봤을 때, " iv(변수)를 여러개 묶어놓은 것 " 그 이상 그 이하도 아님.

*클래스 변수와 인스턴스 변수
class Card{
	String kind;	// 무늬
	int number; 	// 숫자		==> 인스턴스 변수 (개별 속성)
	
	static int width = 100;   // 폭 
	static int height = 250; // 높이 ==> 클래스 변수 (공통 속성)
}
즉, 속성 중에 공통적으로 유지되어야 하는 것에 static을 붙여 준다.
이제 위의 클래스를 사용하려면?

Card c = new Card();	// 객체 생성 
// iv 객체 사용 
c.kind = "HEART";
c.number= 5;

// cv 객체 사용
Card.width = 200;
Card.height = 300; // (정배) 앞에 클래스 이름이 와야함. 

// 이렇게 적어도 작동은 잘 되긴 함, 권장 안함 (iv와 cv를 잘 구별하기 위해)
c.width = 200;
c.height = 300;

----------------------------------------------------------------------
* 메서드란?
1. 문장들을 묶어놓은 것.
    - 작업 단위로 문장들을 묶어서 이름 붙인 것.
2. 값(입력)을 받아서 처리하고, 결과를 반환 (출력)
 ex) 
  int add(int x, int y){		// int: 반환타입/ add: 메서드이름/ int x int y: 매개변수선언(입력)
	int result = x + y;
	return result;			// 결과를 반환 
  } 
3. 메서드의 장점
- 중복 코드 제거 
- 관리 용이
- 코드 재사용 가능 
- 코드가 간결해서 이해하기 쉬워진다.

4. 메서드의 작성 
- 반복적으로 수행되는 여러 문장을 메서드로 작성
- 하나의 메서드는 한 가지 기능만 수행하도록 작성

5. 메서드란?
메서드 = 선언부 + 구현부 

반환타입 메서드이름 (매개변수 목록, ... )   ==> 선언부 (매개변수 목록에는 0~n개 들어갈 수 있다.)
{ // 메서드 호출 시 수행될 코드  }			 ==> 구현부 

 ex) 
  int add(int a, int b){		// 선언부
	int result = a + b;
	return result;			// 구현부 
  } 

6. 지역변수 (lv): 메서드 내에 선언된 변수

int multiply(int a, int b){		
	int result = a * b;
	return result;		 	// 여기서 지역변수는 a, b, result 이 3개	 
  } 					// 메서드 끝날 때까지 유효하고 메서드 끝나면 그냥 사라짐 

---------------------------------------------------------------------
* 메서드의 호출 (call)

메서드 이름(값1, 값2, ...);	// 메서드 호출 방법. 값 자리에는 작업에 필요한 값들을 (있다면)넣어주면 됨
				// 값들을 매개변수 (parameter) 라고 함 
ex)
print99danAll();		// void print99danAll()을 호출
int result = add(3, 5); 	// int add(int x, int y)를 호출 > 결과(8)를 result에 저장 

* 순서 
1. 클래스 작성 (메서드 작성)
class MyMath{
	long add(long a, long b){
		long result = a + b;
		return result;		// return a + b; // 위의 두 줄을 이 한 줄로 간단히 할 수 있음

	long subtract(long a, long b) { return a - b; }
	long multiply(long a, long b) { return a * b; }
	double divide(double a, double b) { return a / b; }
}

2. 클래스 객체 (=인스턴스) 생성
MyMath mm = new MyMath();

3. MyMath 객체 사용 (객체의 메서드 호출)
long result1 = mm.add(5L, 3L);		// add 메서드 호출
long result2 = mm.subtract(5L, 3L);	// subtract 메서드 호출
long value = mm.multiply(5L, 3L); 	// multiply 메서드 호출

// 전체 코드 /////////////////////////////////// 
public static void main(String args[]){
	MyMath mm = new MyMath();
	long result1 = mm.add(5L, 3L);		// add 메서드 호출
	
	System.out.println("add(5L, 3L) = " + result1);


class MyMath{
	long add(long a, long b){
		long result = a + b;
		return result;		// return a + b; // 위의 두 줄을 이 한 줄로 간단히 할 수 있음

	long subtract(long a, long b) { return a - b; }
	long multiply(long a, long b) { return a * b; }
	double divide(double a, double b) { return a / b; }
 }
} ///////////////////////////////////////////

Q. 두 값을 받아서 둘 중에 큰 값을 반환하는 메서드를 작성하시오.
 1. 메서드 작성 
 long max(long a, long b){
	long result = 0;  	// 결과를 담을 변수 생성
	if(a>b){
	    result = a;
	}else{
	    result = b;
	}
	return result;		// return a > b ? a : b; ==> 삼항연산자로 위의 코드 한 번에
 }

 2. 메서드 호출  
 long result = max(5, 3);	// main 부분에다가 메서드 호출

 3. 출력해보자  
 System.out.println("max(5L, 3L) = " + result);	// 5가 출력

* 메서드의 실행 흐름
① main 메서드에서 메서드 add를 호출 > 인수 1L과 2L이 메서드 add의 매개변수 a, b에 각각 복사(대입)된다.
② 메서드 add의 괄호{}안에 있는 문장들이 순서대로 수행됨
③ 메서드 add의 모든 문장이 실행되거나 return문을 만나면, 호출한 메서드(main메서드)로 되돌아옴 > 이후 문장들 실행

--------------------------------------------------------------
* return 문
- 실행 중인 메서드를 종료하고 호출한 곳으로 되돌아간다.

ex)
void printGugudan(int dan){
	if(!(2 <= dan && dan <= 9))
		return;		// dan의 값이 2~9가 아닌 경우, 호출한 곳으로 그냥 돌아간다.
	
	for(int i = 1; i <= 9; i++){
		System.out.printf("%d * %d = %d%n", dan, i, dan * i);
	}
     // return;   // 반환타입이 void이므로 생략가능. 컴파일러가 자동 추가 
}

* 반환 타입이 void가 아닌 경우, 반드시 return문 필요 
ex) 
int max(int a, int b){
	if(a > b) 
	   return a;	// error. 조건식이 참일 때만 return문이 실행되므로 거짓일 때의 else문을 추가해주어야 함
}

ex)
int max(int a, int b){
	if(a > b) 
	   return a;		// 조건식이 참일 때 실행됨
	else
	     return b; 		// 조건식이 거짓일 때 실행됨
}

----------------------------------------------------------------
* 호출 스택 (call stack)
- 스택    : 밑이 막힌 상자. 위에 차곡차곡 쌓인다.
- 호출 스택 : 메서드 수행에 필요한 메모리가 제공되는 공간.
	   메서드가 호출되면 호출스택에 메모리 할당, 종료되면 해제 

ㅣ	  ㅣ					ㅣㅡㅡㅡㅡ ㅣ
ㅣ	    ㅣ					ㅣprintln ㅣ
ㅣㅡㅡㅡㅡ  ㅣ	-> main()이 println()을 호출          ㅣㅡㅡㅡㅡ ㅣ
ㅣ  main   ㅣ					ㅣ main   ㅣ
ㅡㅡㅡㅡㅡㅡ					 ㅡㅡㅡㅡㅡ 

ㅣㅡㅡㅡㅡ ㅣ					ㅣ	  ㅣ
ㅣprintln ㅣ					ㅣ	 ㅣ
ㅣㅡㅡㅡㅡ  ㅣ	-> println()이 종료되면?	             ㅣㅡㅡㅡㅡ ㅣ
ㅣ  main   ㅣ					ㅣ main   ㅣ
ㅡㅡㅡㅡㅡㅡ					 ㅡㅡㅡㅡㅡ      // main메서드가 대기 중 상태다가 실행 상태로 바뀜.

: 즉, 아래 있는 메서드가 위의 메서드를 호출한 것 

-------------------------------------------------------------------
* 기본, 참조형 매개변수 ** ** 중요

메서드의 매개변수가 기본형일 때와 참조형일 때의 차이가 있다. 

▶ 기본형 매개변수 - 변수의 값을 읽기만 할 수 있음 (read only)
ex)
class ex5 {
   public static void main(String[] args){
	Data2 d = new Data2();
	d.x = 10;
	System.out.println("main() : x = " + d.x);

	change(d);
	System.out.println("After change(d.x)");
	System.out.println("main() : x = " + d.x);
   }
   static void change(int x){		// 기본형 매개변수
	x = 1000;
	System.out.println("change() : x = " + x);
   }
}

▶ 참조형 매개변수 - 변수의 값을 읽고 변경할 수 있음 (read & write)

   static void change(Data2 d){		// 참조형 매개변수
	d.x = 1000;
	System.out.println("change() : x = " + d.x);
   }
}

* 참조형 반환타입 
static Data3 copy(Data3 d){
   Data3 tmp = new Data3();     // 새로운 객체 tmp를 생성

   tmp.x = d.x;			// d.x의 값을 tmp.x에 복사

   return tmp;			// 복사한 객체의 주소 반환
}

------------------------------------------------------------------------

